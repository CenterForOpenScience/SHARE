using trove for a dashboard of metrics
======================================

on frontend...

a dashboard has a consistent `cardSearchFilter` set

for each metadata property (or property-path) of interest,
make a request to `/trove/index-value-search` with that `valueSearchPropertyPath`
and the dashboard's `cardSearchFilter` set



denormalized IndexStrategy
==========================

current mappings:
  simple:
    indexcard_uuid
    focus_iri
    suffuniq_focus_iri
    source_record_identifier
    source_config_label
    iri_paths_present
    iri_paths_present_suffuniq
  flattened:
    flat_iri_values
    flat_iri_values_suffuniq
  nested: (THE PROBLEM)
    nested_iri...
    nested_date...
    nested_text...


to denormalize for performance (removing (most) `nested` mappings)
while supporting existing api used by osf-search...

edges to consider:
- `cardSearchText[property.path]`
  - dynamic template for text values per property-path (...to limited depth?)
- `valueSearchFilter[resourceType]`
  - dynamic template for iri values per resource-type?
- `valueSearchText`
  - ...new index for value-search?
  - ...maybe can use the same dynamic fields added for `cardSearchText[property.path]`?
      ...but how to keep the text associated with the iri value...
  - ...could keep the old `nested` garbage around, but only use it when `valueSearchText`?
- `cardSearchFilter[sameAs][iri-prefix]=https://orcid.org/`
  - new filter operator
- `cardSearchText[*.*.*]`, `cardSearchFilter[*.*.*]`
  - dynamic templates for values by depth?


possible future card-index mappings:
  simple:
    indexcard_uuid
    suid.source_config_label
    suid.source_record_identifier
    focus_iri.exact
    focus_iri.suffuniq
    propertypaths_present
  flattened:
    iri_by_propertypath.exact.*
    iri_by_propertypath.suffuniq.*
    iri_by_propertypath_length.exact.*
    iri_by_propertypath_length.suffuniq.*
  dynamic: (used instead of the old nested fields for most queries)
    dynamics.text_by_propertypath.*
    dynamics.text_by_propertypath_length.*
    dynamics.date_by_propertypath.*
    (maybe) dynamics.number_by_propertypath.*
  nested: (ONLY for index-value-search with `valueSearchText` or `valueSearchFilter[resourceType]`)
    iri_usage
      iri.exact
      iri.suffuniq
      propertypath
      propertypath_length
      type_iri.exact
      type_iri.suffuniq
      name_text
      title_text
      label_text
      namelike_text (combined three)


multiple strategies?
====================
after reluctantly accepting `nested` for certain value-searches... how about multiple index strategies?

select suitable index-strategy based on query

most queries go to a more constrained index-strategy with a smaller, faster,
completely non-nested index (calling it "trovesearch_indexcard")

queries that need the extra complexity go to a more complex index-strategy
with larger, slower index (calling it "trovesearch_excessive")

however... even simple value-searches need to get metadata about each iri value
(at least `rdf:type` and something name-like (`dcterms:title`, `foaf:name`, `rdfs:label`...))
-- without the `nested` mapping, there's not a good way (that i see) to do that in a single query

so how about a third index strategy just for looking up iri-value metadata?
(calling it "trovesearch_irivalues")


trovesearch_indexcard (one per indexcard):
  simple:
    indexcard_iri
    indexcard_pk
    suid.source_config_label
    suid.source_record_identifier
    focus_iri.exact
    focus_iri.suffuniq
    propertypaths_present
  flattened:
    iri_by_propertypath.*
    iri_by_depth.*
  dynamic:
    dynamics.text_by_propertypath.*
    dynamics.text_by_depth.*
    dynamics.date_by_propertypath.*


trovesearch_irivalues (one per (indexcard, iri) pair)
  simple:
    iri.exact (includes sameAs synonyms)
    iri.suffuniq (includes sameAs synonyms)
    indexcard_iri
    indexcard_pk
    propertypath_from_focus
    depth_from_focus
  flattened:
    iri_by_relative_propertypath.*
    iri_by_relative_depth.*
  dynamic:
    dynamics.text_by_relative_propertypath.*
    dynamics.text_by_relative_depth.*
    dynamics.date_by_relative_propertypath.*


trovesearch_excessive:
  (all fields from trovesearch_indexcard, plus a nested field with
   fields from (or similar to) trovesearch_irivalues)


...ok maybe, but revisiting "trovesearch_irivalues (one per (indexcard, iri) pair)",
that's a looot of documents, and awful wasteful for the common case of commonly used iris,
and trickier to remove docs for iri values no longer used

returning to an old idea discarded from the first "index-card-search" implementation...
how about an index with (only) one doc per referenced iri? would need to:
- use IDENTIFIER_USAGE/BACKFILL_IDENTIFIER_USAGE messages
    emit after non-backfill indexcard indexing, perhaps deduped within each message chunk
- index strategy should, for each identifier message:
    query for indexcards that include that identifier,
    aggregate metadata included in those indexcards about that identifier,
    store document describing that identifier and its usage

important to account for erroneous sameAs assertions (make it easy to undo)

revised trovesearch_irivalues (one per iri)
  simple:
    iri
    used_at_propertypath
  flattened:
    iri_by_relative_propertypath.*
    iri_by_relative_depth.*
  dynamic:
    dynamics.text_by_relative_propertypath.*
    dynamics.text_by_relative_depth.*
    dynamics.date_by_relative_propertypath.*
